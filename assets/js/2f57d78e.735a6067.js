"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[517],{5934:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>n,metadata:()=>o,toc:()=>h});var a=s(4848),i=s(8453);const n={id:"banditopt",title:"Bandit Optimization"},r=void 0,o={id:"banditopt",title:"Bandit Optimization",description:"Many decision problems require choosing from a discrete set of candidates, and for these problems Ax uses bandit optimization. In contrast to Bayesian optimization \u2014 which provides a solution for problems with continuous parameters and an infinite number of potential options \u2014 bandit optimization is used for problems with a finite set of choices. Most ordinary A/B tests, in which a handful of options are evaluated against each other, fall into this category. Experimenters typically perform such tests by allocating a fixed percentage of experimental units to each choice, waiting to collect data about each, and then choosing a winner. In the case of an online system receiving incoming requests, this can be done by splitting traffic amongst the choices. However, with more than just a few options A/B tests quickly become prohibitively resource-intensive, largely because all choices \u2014 no matter how good or bad they appear \u2014 receive the same traffic allocation.",source:"@site/versioned_docs/version-0.1.1/banditopt.md",sourceDirName:".",slug:"/banditopt",permalink:"/Ax/docs/banditopt",draft:!1,unlisted:!1,tags:[],version:"0.1.1",lastUpdatedBy:"Cristian Lara",lastUpdatedAt:1731804178e3,frontMatter:{id:"banditopt",title:"Bandit Optimization"},sidebar:"docs",previous:{title:"Bayesian Optimization",permalink:"/Ax/docs/bayesopt"},next:{title:"Core",permalink:"/Ax/docs/core"}},l={},h=[{value:"How does it work?",id:"how-does-it-work",level:2},{value:"How well does it work?",id:"how-well-does-it-work",level:2},{value:"Empirical Bayes",id:"empirical-bayes",level:2}];function c(e){const t={a:"a",annotation:"annotation",em:"em",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["Many decision problems require choosing from a discrete set of candidates, and for these problems Ax uses bandit optimization. In contrast to ",(0,a.jsx)(t.a,{href:"/Ax/docs/bayesopt",children:"Bayesian optimization"})," \u2014 which provides a solution for problems with continuous parameters and an infinite number of potential options \u2014 bandit optimization is used for problems with a finite set of choices. Most ordinary A/B tests, in which a handful of options are evaluated against each other, fall into this category. Experimenters typically perform such tests by allocating a fixed percentage of experimental units to each choice, waiting to collect data about each, and then choosing a winner. In the case of an online system receiving incoming requests, this can be done by splitting traffic amongst the choices. However, with more than just a few options A/B tests quickly become prohibitively resource-intensive, largely because all choices \u2014 no matter how good or bad they appear \u2014 receive the same traffic allocation."]}),"\n",(0,a.jsxs)(t.p,{children:["Bandit optimization allocates traffic more efficiently among these discrete choices by sequentially updating the allocation of traffic based on each candidate's performance so far. The key problem for bandit optimization algorithms is balancing exploration (sending traffic to candidates that have the potential to perform well) with exploitation (sending traffic to candidates which already appear to perform well). This trade-off is very similar to the underlying exploration problem highlighted in Bayesian Optimization ",(0,a.jsx)(t.a,{href:"/Ax/docs/bayesopt#acquisition-functions",children:"acquisition functions"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Bandit optimization is more sample efficient than traditional static A/B tests: it acquires a greater reward for the same amount of experimentation. Consequently, it is safer with larger cohorts because the samples are automatically diverted towards the good parameter values (and away from the bad ones)."}),"\n",(0,a.jsx)(t.h2,{id:"how-does-it-work",children:"How does it work?"}),"\n",(0,a.jsxs)(t.p,{children:["Ax relies on the simple and effective ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Thompson_sampling",children:"Thompson sampling"}),' algorithm for performing bandit optimization. There is a clear intuition to this method: select a parameterization (referred to from now on as an "arm") with a probability proportional to that arm being the best. This algorithm is easy to implement and has strong guarantees of converging to an arm that is close to the best \u2014 all without any human intervention. To understand how this works, we describe an advertising optimization problem in which we want to choose arms which maximize the click-through rate (CTR) and the rewards are binary: either clicks (successes) or views without clicks (failures).']}),"\n",(0,a.jsx)(t.p,{children:"As we run the experiment, we develop more precise estimates of the performance of each arm. More precisely, in each iteration, we draw samples from the distribution of plausible effects for each arm, and we record the largest sampled value. We repeat this process many times, until settling on a final distribution of maximal arms, which determines how we assign users to arms going forward. This process rapidly narrows down our set of arms to only the very best performers."}),"\n",(0,a.jsx)(t.p,{children:"The following figure is an example of how assignment probabilities for an experiment with 10 arms may evolve over 20 iterations of batch-based Thompson sampling:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Bandit Optimization Allocations",src:s(6213).A+"",width:"3000",height:"1500"})}),"\n",(0,a.jsx)(t.p,{children:"The process starts by distributing users equally among all of the arms. Bandit optimization then produces updated assignment probabilities (represented here by the height of the colored bars in each column) based on the average CTR observed up until that point. Since the true CTR is highest for the second arm, followed by the first arm, in this simulated example those arms are subsequently given larger allocations over 20 rounds of optimization."}),"\n",(0,a.jsxs)(t.p,{children:["Early in the process, the uncertainty in our estimates of CTR means that the bandit optimization spreads samples somewhat evenly amongst arms. This helps us obtain better estimates for all of the arms and allows us to start focusing in on those which perform well. The following figure animates this evolution. The small blue x indicates the observed CTRs within each round, while the solid round symbol (and gray error bars) indicate our aggregated estimates across all rounds. Arms 3 through 8 are sampled just often enough to get a rough estimate that their CTRs are low, and the algorithm then focuses further exploration on the first two arms to better identify which is the best. This example can be viewed as a discretized version of the animated example of ",(0,a.jsx)(t.a,{href:"/Ax/docs/bayesopt",children:"Bayesian optimization"}),"."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Bandit Optimization: Posteriors",src:s(5616).A+"",width:"750",height:"450"})}),"\n",(0,a.jsx)(t.h2,{id:"how-well-does-it-work",children:"How well does it work?"}),"\n",(0,a.jsx)(t.p,{children:'We want a bandit algorithm to maximize the total rewards over time or equivalently, to minimize the regret, which is defined as the cumulative difference between the highest possible reward and the actual reward at a point in time. In our running example, regret is the number of clicks we "left on the table" through our choice of allocation procedure. We can imagine two extremes:'}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Pure exploration, in which we just always allocate users evenly across all conditions. This is the standard approach to A/B tests."}),"\n",(0,a.jsx)(t.li,{children:"Pure exploitation, in which we simply allocate all users to the arm we think is most likely to be best."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Both of these extremes will do a poor job of minimizing our regret, so our aim is to balance them."}),"\n",(0,a.jsx)(t.p,{children:"The following figure compares the cumulative regret of three different approaches to bandit optimization for 200 rounds of experimentation on our running example:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Thompson sampling: the primary approach used by Ax, described above"}),"\n",(0,a.jsx)(t.li,{children:"Greedy: select the arm with the current best reward"}),"\n",(0,a.jsxs)(t.li,{children:["Epsilon-greedy: randomly picks an arm ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsx)(t.mrow,{children:(0,a.jsx)(t.mi,{children:"e"})}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"e"})]})})}),(0,a.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",children:"e"})]})})]})," percent of the time, picks the current best arm ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mn,{children:"100"}),(0,a.jsx)(t.mo,{children:"\u2212"}),(0,a.jsx)(t.mi,{children:"e"})]}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"100-e"})]})})}),(0,a.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(t.span,{className:"mord",children:"100"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(t.span,{className:"mbin",children:"\u2212"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",children:"e"})]})]})]})," percent of the time"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Bandit Optimization: Regret",src:s(2810).A+"",width:"3000",height:"2100"})}),"\n",(0,a.jsxs)(t.p,{children:["The regret of the purely greedy approach is the highest amongst the three approaches. A little bit of exploration, as in the epsilon-greedy approach with ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mi,{children:"e"}),(0,a.jsx)(t.mo,{children:"="}),(0,a.jsx)(t.mn,{children:"10"})]}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"e = 10"})]})})}),(0,a.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",children:"e"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mrel",children:"="}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(t.span,{className:"mord",children:"10"})]})]})]}),", leads to much less regret over time. Thompson sampling best balances the tradeoff between exploration and exploitation, and thus outperforms the other two approaches."]}),"\n",(0,a.jsx)(t.p,{children:"As it turns out, we can do even better by applying a simple model."}),"\n",(0,a.jsx)(t.h2,{id:"empirical-bayes",children:"Empirical Bayes"}),"\n",(0,a.jsx)(t.p,{children:'In short, our empirical Bayes model consists of taking noisy estimates from a bunch of arms and "shrinking" the outlying ones a bit towards the overall central tendency across all arms.'}),"\n",(0,a.jsxs)(t.p,{children:["The specific method we use is ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/James%E2%80%93Stein_estimator",children:"James-Stein estimation"}),". This method is linear, which means that if multiple arms have estimates with similar levels of precision, they will be moved towards the middle of the effect distribution proportionally to their distance from the middle. Doing this turns out to be optimal in the case of a Gaussian distribution of effects, but will improve accuracy even if that isn't the case (so long as there are ",(0,a.jsx)(t.a,{href:"https://projecteuclid.org/download/pdf_1/euclid.bsmsp/1200501656",children:"at least three means"}),")."]}),"\n",(0,a.jsx)(t.p,{children:"The diagram below illustrates how the estimates of two different experiments change as a result of applying the empirical Bayes estimator."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Shrinkage in two representative experiments",src:s(299).A+"",width:"1382",height:"829"})}),"\n",(0,a.jsxs)(t.p,{children:["The experiment on the left has large effects relative to estimation variability, and so shrinkage (visualized here as distance from the dashed ",(0,a.jsxs)(t.span,{className:"katex",children:[(0,a.jsx)(t.span,{className:"katex-mathml",children:(0,a.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(t.semantics,{children:[(0,a.jsxs)(t.mrow,{children:[(0,a.jsx)(t.mi,{children:"y"}),(0,a.jsx)(t.mo,{children:"="}),(0,a.jsx)(t.mi,{children:"x"})]}),(0,a.jsx)(t.annotation,{encoding:"application/x-tex",children:"y=x"})]})})}),(0,a.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"y"}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,a.jsx)(t.span,{className:"mrel",children:"="}),(0,a.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,a.jsxs)(t.span,{className:"base",children:[(0,a.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,a.jsx)(t.span,{className:"mord mathnormal",children:"x"})]})]})]})," line), is very small. On the right side, however, we can see an experiment where shrinkage makes a significant difference. Effects far from the center of the distribution result in fairly substantial shrinkage, reducing the range of effects by nearly half. While effect estimates in the middle were largely unchanged, the largest observed effects went from around 17% before shrinkage to around 8% afterwards."]}),"\n",(0,a.jsxs)(t.p,{children:["The vast majority of experimental groups are estimated more accurately using empirical Bayes. The arms which tend to have increases in error are those with the largest effects. Understating the effects of such arms is usually not a very big deal when making launch decisions, however, as one is usually most interested in ",(0,a.jsx)(t.em,{children:"which"})," arm is the best rather than exactly how good it is."]}),"\n",(0,a.jsxs)(t.p,{children:["Using Empirical Bayes does better at allocating users to the best arm than does using the raw effect estimates. It does this by concentrating exploration early in the experiment. In particular, it concentrates that exploration on the ",(0,a.jsx)(t.em,{children:"set"})," of arms that look good, rather than over-exploiting the single best performing arm. By spreading exploration out a little bit more when effect estimates are noisy (and playing the best arm a little less), it is able to identify the best arm with more confidence later in the experiment."]}),"\n",(0,a.jsxs)(t.p,{children:["See more ",(0,a.jsx)(t.a,{href:"https://arxiv.org/abs/1904.12918",children:"details in our paper"}),"."]})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},299:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/example_shrinkage-8a5989b83cc948f111dffca541fc6056.png"},5616:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/mab_animate-c0cde777bd9e9b6eaff9ba9df032d7f9.gif"},6213:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/mab_probs-462b1545c3111a86582304f5b234f74a.png"},2810:(e,t,s)=>{s.d(t,{A:()=>a});const a=s.p+"assets/images/mab_regret-0d028c35ce62cc71935e779b64d9f4ba.png"},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>o});var a=s(6540);const i={},n=a.createContext(i);function r(e){const t=a.useContext(n);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(n.Provider,{value:t},e.children)}}}]);