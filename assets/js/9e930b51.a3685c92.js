"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[345],{7649:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=t(4848),a=t(8453),r=t(8987);t(1023),t(290);const o={title:"Visualizations",sidebar_label:"Visualizations"},l="Visualizations",s={id:"tutorials/visualizations/index",title:"Visualizations",description:"<LinkButtons",source:"@site/../docs/tutorials/visualizations/index.mdx",sourceDirName:"tutorials/visualizations",slug:"/tutorials/visualizations/",permalink:"/Ax/docs/tutorials/visualizations/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Visualizations",sidebar_label:"Visualizations"},sidebar:"tutorials",previous:{title:"Developer API",permalink:"/Ax/docs/tutorials/gpei_hartmann_developer/"},next:{title:"Generation Strategy",permalink:"/Ax/docs/tutorials/generation_strategy/"}},c={},d=[{value:"1. Create experiment and run optimization",id:"1-create-experiment-and-run-optimization",level:2},{value:"1a. Define search space and evaluation function",id:"1a-define-search-space-and-evaluation-function",level:4},{value:"1b. Create Experiment",id:"1b-create-experiment",level:4},{value:"1c. Run the optimization and fit a GP on all data",id:"1c-run-the-optimization-and-fit-a-gp-on-all-data",level:4},{value:"2. Contour plots",id:"2-contour-plots",level:2},{value:"2a. Interactive contour plot",id:"2a-interactive-contour-plot",level:4},{value:"3. Tradeoff plots",id:"3-tradeoff-plots",level:2},{value:"4. Cross-validation plots",id:"4-cross-validation-plots",level:2},{value:"5. Slice plots",id:"5-slice-plots",level:2},{value:"6. Tile plots",id:"6-tile-plots",level:2},{value:"Fix for plots that are not rendering",id:"fix-for-plots-that-are-not-rendering",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.A,{githubUrl:"",colabUrl:""}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"visualizations",children:"Visualizations"})}),"\n",(0,i.jsx)(n.p,{children:"This tutorial illustrates the core visualization utilities available in Ax."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import numpy as np\n\nfrom ax.modelbridge.cross_validation import cross_validate\nfrom ax.plot.contour import interact_contour\nfrom ax.plot.diagnostic import interact_cross_validation\nfrom ax.plot.scatter import interact_fitted, plot_objective_vs_constraints, tile_fitted\nfrom ax.plot.slice import plot_slice\nfrom ax.service.ax_client import AxClient, ObjectiveProperties\nfrom ax.utils.measurement.synthetic_functions import hartmann6\nfrom ax.utils.notebook.plotting import init_notebook_plotting, render\n\ninit_notebook_plotting()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"1-create-experiment-and-run-optimization",children:"1. Create experiment and run optimization"}),"\n",(0,i.jsx)(n.p,{children:"The vizualizations require an experiment object and a model fit on the evaluated data.\nThe routine below is a copy of the Service API tutorial, so the explanation here is\nomitted. Retrieving the experiment and model objects for each API paradigm is shown in\nthe respective tutorials"}),"\n",(0,i.jsx)(n.h4,{id:"1a-define-search-space-and-evaluation-function",children:"1a. Define search space and evaluation function"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'noise_sd = 0.1\nparam_names = [f"x{i+1}" for i in range(6)]  # x1, x2, ..., x6\n\n\ndef noisy_hartmann_evaluation_function(parameterization):\n    x = np.array([parameterization.get(p_name) for p_name in param_names])\n    noise1, noise2 = np.random.normal(0, noise_sd, 2)\n\n    return {\n        "hartmann6": (hartmann6(x) + noise1, noise_sd),\n        "l2norm": (np.sqrt((x**2).sum()) + noise2, noise_sd),\n    }\n'})}),"\n",(0,i.jsx)(n.h4,{id:"1b-create-experiment",children:"1b. Create Experiment"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'ax_client = AxClient()\nax_client.create_experiment(\n    name="test_visualizations",\n    parameters=[\n        {\n            "name": p_name,\n            "type": "range",\n            "bounds": [0.0, 1.0],\n        }\n        for p_name in param_names\n    ],\n    objectives={"hartmann6": ObjectiveProperties(minimize=True)},\n    outcome_constraints=["l2norm <= 1.25"],\n)\n'})}),"\n",(0,i.jsx)(n.h4,{id:"1c-run-the-optimization-and-fit-a-gp-on-all-data",children:"1c. Run the optimization and fit a GP on all data"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"for i in range(20):\n    parameters, trial_index = ax_client.get_next_trial()\n    # Local evaluation here can be replaced with deployment to external system.\n    ax_client.complete_trial(\n        trial_index=trial_index, raw_data=noisy_hartmann_evaluation_function(parameters)\n    )\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2-contour-plots",children:"2. Contour plots"}),"\n",(0,i.jsxs)(n.p,{children:["The plot below shows the response surface for ",(0,i.jsx)(n.code,{children:"hartmann6"})," metric as a function of the\n",(0,i.jsx)(n.code,{children:"x1"}),", ",(0,i.jsx)(n.code,{children:"x2"})," parameters."]}),"\n",(0,i.jsx)(n.p,{children:"The other parameters are fixed in the middle of their respective ranges, which in this\nexample is 0.5 for all of them."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# this could alternately be done with `ax.plot.contour.plot_contour`\nrender(ax_client.get_contour_plot(param_x="x1", param_y="x2", metric_name="hartmann6"))\n'})}),"\n",(0,i.jsx)(n.h4,{id:"2a-interactive-contour-plot",children:"2a. Interactive contour plot"}),"\n",(0,i.jsx)(n.p,{children:"The plot below allows toggling between different pairs of parameters to view the\ncontours."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'model = ax_client.generation_strategy.model\nrender(interact_contour(model=model, metric_name="hartmann6"))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"3-tradeoff-plots",children:"3. Tradeoff plots"}),"\n",(0,i.jsx)(n.p,{children:"This plot illustrates the tradeoffs achievable for 2 different metrics. The plot takes\nthe x-axis metric as input (usually the objective) and allows toggling among all other\nmetrics for the y-axis."}),"\n",(0,i.jsx)(n.p,{children:"This is useful to get a sense of the pareto frontier (i.e. what is the best objective\nvalue achievable for different bounds on the constraint)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'render(plot_objective_vs_constraints(model, "hartmann6", rel=False))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"4-cross-validation-plots",children:"4. Cross-validation plots"}),"\n",(0,i.jsx)(n.p,{children:"CV plots are useful to check how well the model predictions calibrate against the actual\nmeasurements. If all points are close to the dashed line, then the model is a good\npredictor of the real data."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"cv_results = cross_validate(model)\nrender(interact_cross_validation(cv_results))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"5-slice-plots",children:"5. Slice plots"}),"\n",(0,i.jsx)(n.p,{children:"Slice plots show the metric outcome as a function of one parameter while fixing the\nothers. They serve a similar function as contour plots."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'render(plot_slice(model, "x2", "hartmann6"))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"6-tile-plots",children:"6. Tile plots"}),"\n",(0,i.jsx)(n.p,{children:"Tile plots are useful for viewing the effect of each arm."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"render(interact_fitted(model, rel=False))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"fix-for-plots-that-are-not-rendering",children:"Fix for plots that are not rendering"}),"\n",(0,i.jsxs)(n.p,{children:['In certain environments like Google Colab or remote setups, plots may not render. If\nthis is the case, we recommend using the below workaround which overrides the default\nrenderer in plotly. The below cell changes the renderer to "jupyterlab" for this\ntutorial, but you can find the right renderer for your use case by calling\n',(0,i.jsx)(n.code,{children:"pio.renderers"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import plotly.io as pio\npio.renderers.default = "jupyterlab"\n\nrender(ax_client.get_contour_plot(param_x="x1", param_y="x2", metric_name="hartmann6"))\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},1023:(e,n,t)=>{t.d(n,{A:()=>h});t(6540);var i,a=new Uint8Array(16);function r(){if(!i&&!(i="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return i(a)}const o=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;const l=function(e){return"string"==typeof e&&o.test(e)};for(var s=[],c=0;c<256;++c)s.push((c+256).toString(16).substr(1));const d=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=(s[e[n+0]]+s[e[n+1]]+s[e[n+2]]+s[e[n+3]]+"-"+s[e[n+4]]+s[e[n+5]]+"-"+s[e[n+6]]+s[e[n+7]]+"-"+s[e[n+8]]+s[e[n+9]]+"-"+s[e[n+10]]+s[e[n+11]]+s[e[n+12]]+s[e[n+13]]+s[e[n+14]]+s[e[n+15]]).toLowerCase();if(!l(t))throw TypeError("Stringified UUID is invalid");return t};const p=function(e,n,t){var i=(e=e||{}).random||(e.rng||r)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,n){t=t||0;for(var a=0;a<16;++a)n[t+a]=i[a];return n}return d(i)};var u=t(4848);const h=function(e){return(0,u.jsxs)("div",{style:{backgroundColor:"lightgray",marginBottom:"var(--ifm-leading)",borderRadius:"var(--ifm-global-radius)",boxShadow:"var(--ifm-global-shadow-lw)",overflow:"hidden",padding:"10px",font:"var(--ifm-code-font-size) / var(--ifm-pre-line-height) var(--ifm-font-family-monospace)"},children:[(0,u.jsx)("span",{style:{color:"red"},children:"Out: "}),(0,u.jsx)("pre",{style:{margin:"0px",backgroundColor:"inherit"},children:e.children.split("\n").map((function(e){return(0,u.jsx)("p",{style:{marginBottom:"0px"},children:e},p())}))})]})}},8987:(e,n,t)=>{t.d(n,{A:()=>r});t(6540);var i=t(8774),a=t(4848);const r=function(e){var n=e.githubUrl,t=e.colabUrl;return(0,a.jsxs)("div",{className:"link-buttons",children:[(0,a.jsx)(i.A,{to:n,children:"Open in GitHub"}),(0,a.jsx)("div",{}),(0,a.jsx)(i.A,{to:t,children:"Run in Google Colab"})]})}},290:(e,n,t)=>{t(6540);var i=t(3259),a=t.n(i),r=(t(2303),t(4848));a()({loader:function(){return t.e(236).then(t.bind(t,1236))},loading:function(e){return e.timedOut?(0,r.jsx)("blockquote",{children:"Error: Loading Plotly timed out."}):(0,r.jsx)("div",{children:"loading..."})},timeout:1e4})},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);