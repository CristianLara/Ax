"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[867],{5680:(e,a,t)=>{t.d(a,{xA:()=>m,yg:()=>h});var r=t(6540);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var d=r.createContext({}),s=function(e){var a=r.useContext(d),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},m=function(e){var a=s(e.components);return r.createElement(d.Provider,{value:a},e.children)},p="mdxType",g={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},c=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,o=e.originalType,d=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(t),c=n,h=p["".concat(d,".").concat(c)]||p[c]||g[c]||o;return t?r.createElement(h,i(i({ref:a},m),{},{components:t})):r.createElement(h,i({ref:a},m))}));function h(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var o=t.length,i=new Array(o);i[0]=c;var l={};for(var d in a)hasOwnProperty.call(a,d)&&(l[d]=a[d]);l.originalType=e,l[p]="string"==typeof e?e:n,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},2844:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>m,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var r=t(8168),n=t(8587),o=(t(6540),t(5680)),i=["components"],l={id:"models",title:"Models"},d=void 0,s={unversionedId:"models",id:"models",title:"Models",description:"Using models in Ax",source:"@site/../docs/models.md",sourceDirName:".",slug:"/models",permalink:"/Ax/docs/models",draft:!1,tags:[],version:"current",lastUpdatedBy:"Cristian Lara",lastUpdatedAt:1727119127,formattedLastUpdatedAt:"Sep 23, 2024",frontMatter:{id:"models",title:"Models"},sidebar:"docs",previous:{title:"Data",permalink:"/Ax/docs/data"},next:{title:"Storage",permalink:"/Ax/docs/storage"}},m={},p=[{value:"Using models in Ax",id:"using-models-in-ax",level:2},{value:"Sobol sequence",id:"sobol-sequence",level:4},{value:"Gaussian Process with EI",id:"gaussian-process-with-ei",level:4},{value:"Support for mixed search spaces and categorical variables",id:"support-for-mixed-search-spaces-and-categorical-variables",level:4},{value:"Empirical Bayes and Thompson sampling",id:"empirical-bayes-and-thompson-sampling",level:4},{value:"Factorial designs",id:"factorial-designs",level:4},{value:"Deeper dive: organization of the modeling stack",id:"deeper-dive-organization-of-the-modeling-stack",level:2},{value:"Transforms",id:"transforms",level:2},{value:"Implementing new models",id:"implementing-new-models",level:2},{value:"Using an existing Model interface",id:"using-an-existing-model-interface",level:3},{value:"Creating a new Model interface",id:"creating-a-new-model-interface",level:3}],g={toc:p},c="wrapper";function h(e){var a=e.components,t=(0,n.A)(e,i);return(0,o.yg)(c,(0,r.A)({},g,t,{components:a,mdxType:"MDXLayout"}),(0,o.yg)("h2",{id:"using-models-in-ax"},"Using models in Ax"),(0,o.yg)("p",null,"In the optimization algorithms implemented by Ax, models predict the outcomes of metrics within an experiment evaluated at a parameterization, and are used to predict metrics or suggest new parameterizations for trials. Models in Ax are created using factory functions from the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#module-ax.modelbridge.factory"},(0,o.yg)("inlineCode",{parentName:"a"},"ax.modelbridge.factory")),". All of these models share a common API with ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict()"))," to make predictions at new points and ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen()"))," to generate new candidates to be tested. There are a variety of models available in the factory; here we describe the usage patterns for the primary model types and show how the various Ax utilities can be used with models."),(0,o.yg)("h4",{id:"sobol-sequence"},"Sobol sequence"),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.factory.get_sobol"},(0,o.yg)("inlineCode",{parentName:"a"},"get_sobol"))," function is used to construct a model that produces a quasirandom Sobol sequence when",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen"))," is called. This code generates a scrambled Sobol sequence of 10 points:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.modelbridge.factory import get_sobol\n\nm = get_sobol(search_space)\ngr = m.gen(n=10)\n")),(0,o.yg)("p",null,"The output of ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen"))," is a ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.generator_run.GeneratorRun"},(0,o.yg)("inlineCode",{parentName:"a"},"GeneratorRun"))," object that contains the generated points, along with metadata about the generation process. The generated arms can be accessed at ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.generator_run.GeneratorRun.arms"},(0,o.yg)("inlineCode",{parentName:"a"},"GeneratorRun.arms")),"."),(0,o.yg)("p",null,"Additional arguments can be passed to ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.factory.get_sobol"},(0,o.yg)("inlineCode",{parentName:"a"},"get_sobol"))," such as ",(0,o.yg)("inlineCode",{parentName:"p"},"scramble=False")," to disable scrambling, and ",(0,o.yg)("inlineCode",{parentName:"p"},"seed")," to set a seed (see ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.random.sobol.SobolGenerator"},"model API"),")."),(0,o.yg)("p",null,"Sobol sequences are typically used to select initialization points, and this model does not implement ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict")),". It can be used on search spaces with any combination of discrete and continuous parameters."),(0,o.yg)("h4",{id:"gaussian-process-with-ei"},"Gaussian Process with EI"),(0,o.yg)("p",null,"Gaussian Processes (GPs) are used for ",(0,o.yg)("a",{parentName:"p",href:"/Ax/docs/bayesopt"},"Bayesian Optimization")," in Ax, the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.factory.get_gpei"},(0,o.yg)("inlineCode",{parentName:"a"},"get_GPEI"))," function constructs a model that fits a GP to the data, and uses the EI acquisition function to generate new points on calls to ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen")),". This code fits a GP and generates a batch of 5 points which maximizes EI:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.modelbridge.factory import get_GPEI\n\nm = get_GPEI(experiment, data)\ngr = m.gen(n=5, optimization_config=optimization_config)\n")),(0,o.yg)("p",null,"In contrast to ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.factory.get_sobol"},(0,o.yg)("inlineCode",{parentName:"a"},"get_sobol")),", the GP requires data and is able to make predictions. We make predictions by constructing a list of ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.observation.ObservationFeatures"},(0,o.yg)("inlineCode",{parentName:"a"},"ObservationFeatures"))," objects with the parameter values for which we want predictions:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.core.observation import ObservationFeatures\n\nobs_feats = [\n    ObservationFeatures(parameters={'x1': 3.14, 'x2': 2.72}),\n    ObservationFeatures(parameters={'x1': 1.41, 'x2': 1.62}),\n]\nf, cov = m.predict(obs_feats)\n")),(0,o.yg)("p",null,"The output of ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict"))," is the mean estimate of each metric and the covariance (across metrics) for each point."),(0,o.yg)("p",null,"All Ax models that implement ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict"))," can be used with the built-in plotting utilities, which can produce plots of model predictions on 1-d or 2-d slices of the parameter space:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.plot.slice import plot_slice\nfrom ax.utils.notebook.plotting import render, init_notebook_plotting\n\ninit_notebook_plotting()\nrender(plot_slice(\n    model=m,\n    param_name='x1',  # slice on values of 'x1'\n    metric_name='metric_a',\n    slice_values={'x2': 7.5},  # Fix at this value for the slice\n))\n")),(0,o.yg)("div",{id:"slice",style:{width:"100%"}}),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.plot.contour import plot_contour\n\nrender(plot_contour(\n    model=m,\n    param_x='x1',\n    param_y='x2',\n    metric_name='metric_a',\n))\n")),(0,o.yg)("div",{id:"contour",style:{width:"100%"}}),(0,o.yg)("p",null,"Ax also includes utilities for cross validation to assess model predictive performance. Leave-one-out cross validation can be performed as follows:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.modelbridge.cross_validation import cross_validate, compute_diagnostics\n\ncv = cross_validate(model)\ndiagnostics = compute_diagnostics(cv)\n")),(0,o.yg)("p",null,(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.cross_validation.compute_diagnostics"},(0,o.yg)("inlineCode",{parentName:"a"},"compute_diagnostics"))," computes a collection of diagnostics of model predictions, such as the correlation between predictions and actual values, and the p-value for a Fisher test of the model's ability to distinguish high values from low. A very useful tool for assessing model performance is to plot the cross validated predictions against the actual observed values:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.plot.diagnostic import interact_cross_validation\n\nrender(interact_cross_validation(cv))\n")),(0,o.yg)("div",{id:"cv",style:{width:"100%"}}),(0,o.yg)("p",null,"If the model fits the data well, the values will lie along the diagonal. Poor GP fits tend to produce cross validation plots that are flat with high predictive uncertainty - such fits are unlikely to produce good candidates in ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen")),"."),(0,o.yg)("p",null,"By default, this model will apply a number of transformations to the feature space, such as one-hot encoding of ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.parameter.ChoiceParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"ChoiceParameters"))," and log transformation of ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.parameter.RangeParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"RangeParameters"))," which have ",(0,o.yg)("inlineCode",{parentName:"p"},"log_scale")," set to ",(0,o.yg)("inlineCode",{parentName:"p"},"True"),". Transforms are also applied to the observed outcomes, such as standardizing the data for each metric. See ",(0,o.yg)("a",{parentName:"p",href:"/Ax/docs/models#Transforms"},"the section below on Transforms")," for a description of the default transforms, and how new transforms can be implemented and included."),(0,o.yg)("p",null,"GPs typically does a good job of modeling continuous parameters (",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.parameter.RangeParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"RangeParameters")),"). If the search space contains ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.parameter.ChoiceParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"ChoiceParameters")),", they will be one-hot-encoded and the GP fit in the encoded space. A search space with a mix of continuous parameters and ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.parameter.ChoiceParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"ChoiceParameters"))," that take a small number of values can be modeled effectively with a GP, but model performance may be poor if there are more than about 20 parameters after one-hot encoding. Cross validation is an effective tool for determining usefulness of the GP on a particular problem."),(0,o.yg)("p",null,"In discrete spaces where the GP does not predict well, a multi-armed bandit approach is often preferred, and we now discuss the models suitable for that approach."),(0,o.yg)("h4",{id:"support-for-mixed-search-spaces-and-categorical-variables"},"Support for mixed search spaces and categorical variables"),(0,o.yg)("p",null,"The most common way of dealing with categorical variables in Bayesian optimization is to one-hot encode the categories to allow fitting a GP model in a continuous space. In this setting, a categorical variable with categories ",(0,o.yg)("inlineCode",{parentName:"p"},'["red", "blue", "green"]')," is represented by three new variables (one for each category). While this is a convenient choice, it can drastically increase the dimensionality of the search space. In addition, the acquisition function is often optimized in the corresponding continuous space and the final candidate is selected by rounding back to the original space, which may result in selecting sub-optimal points according to the acquisition function."),(0,o.yg)("p",null,"Our new approach uses separate kernels for the categorical and ordinal (continuous/integer) variables. In particular, we use a kernel of the form: $$k(x, y) = k",(0,o.yg)("em",{parentName:"p"},"\\",'text{"{"}cat{"}"}(x'),"\\",'text{"{"}cat{"}"}, y',(0,o.yg)("em",{parentName:"p"},"\\",'text{"{"}cat{"}"}) ',"\\","times k"),"\\",'text{"{"}ord{"}"}(x',(0,o.yg)("em",{parentName:"p"},"\\",'text{"{"}ord{"}"}, y'),"\\",'text{"{"}ord{"}"}) + k',(0,o.yg)("em",{parentName:"p"},"\\",'text{"{"}cat{"}"}(x'),"\\",'text{"{"}cat{"}"}, y',(0,o.yg)("em",{parentName:"p"},"\\",'text{"{"}cat{"}"}) + k'),"\\",'text{"{"}ord{"}"}(x',(0,o.yg)("em",{parentName:"p"},"\\",'text{"{"}ord{"}"}, y'),"\\",'text{"{"}ord{"}"})$$\nFor the ordinal variables we can use a standard kernel such as Mat\xe9rn-5/2, but for the categorical variables we need a way to compute distances between the different categories. A natural choice is to set the distance is 0 if two categories are equal and 1 otherwise, similar to the idea of Hamming distances. This approach can be combined with the idea automatic relevance determination (ARD) where each categorical variable has its own lengthscale. Rather than optimizing the acquisition function in a continuously relaxed space, we optimize it separately over each combination of the categorical variables. While this is likely to result in better optimization performance, it may lead to slow optimization of the acquisition function when there are many categorical variables.'),(0,o.yg)("h4",{id:"empirical-bayes-and-thompson-sampling"},"Empirical Bayes and Thompson sampling"),(0,o.yg)("p",null,"For ",(0,o.yg)("a",{parentName:"p",href:"/Ax/docs/banditopt"},"Bandit optimization"),", The ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.factory.get_empirical_bayes_thompson"},(0,o.yg)("inlineCode",{parentName:"a"},"get_empirical_bayes_thompson"))," factory function returns a model that applies ",(0,o.yg)("a",{parentName:"p",href:"/Ax/docs/banditopt#empirical-bayes"},"empirical Bayes shrinkage")," to a discrete set of arms, and then uses Thompson sampling to construct a policy with the weight that should be allocated to each arms. Here we apply empirical Bayes to the data and use Thompson sampling to generate a policy that is truncated at ",(0,o.yg)("inlineCode",{parentName:"p"},"n=10")," arms:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.modelbridge.factory import get_empirical_bayes_thompson\n\nm = get_empirical_bayes_thompson(experiment, data)\ngr = m.gen(n=10, optimization_config=optimization_config)\n")),(0,o.yg)("p",null,"The arms and their corresponding weights can be accessed as ",(0,o.yg)("inlineCode",{parentName:"p"},"gr.arm_weights"),"."),(0,o.yg)("p",null,"As with the GP, we can use ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict"))," to evaluate the model at points of our choosing. However, because this is a purely in-sample model, those points should correspond to arms that were in the data. The model prediction will return the estimate at that point after applying the empirical Bayes shrinkage:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"f, cov = m.predict([ObservationFeatures(parameters={'x1': 3.14, 'x2': 2.72})])\n")),(0,o.yg)("p",null,"We can generate a plot that shows the predictions for each arm with the shrinkage using ",(0,o.yg)("a",{parentName:"p",href:"../api/plot.html#ax.plot.scatter.plot_fitted"},(0,o.yg)("inlineCode",{parentName:"a"},"plot_fitted")),", which shows model predictions on all in-sample arms:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},'from ax.plot.scatter import plot_fitted\n\nrender(plot_fitted(m, metric="metric_a", rel=False))\n')),(0,o.yg)("div",{id:"fitted",style:{width:"100%"}}),(0,o.yg)("h4",{id:"factorial-designs"},"Factorial designs"),(0,o.yg)("p",null,"The factory function ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.factory.get_factorial"},(0,o.yg)("inlineCode",{parentName:"a"},"get_factorial"))," can be used to construct a factorial design on a set of ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.parameter.ChoiceParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"ChoiceParameters")),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"from ax.modelbridge.factory import get_factorial\n\nm = get_factorial(search_space)\ngr = m.gen(n=10)\n")),(0,o.yg)("p",null,"Like the Sobol sequence, the factorial model is only used to generate points and does not implement ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict")),"."),(0,o.yg)("h2",{id:"deeper-dive-organization-of-the-modeling-stack"},"Deeper dive: organization of the modeling stack"),(0,o.yg)("p",null,"Ax uses a bridge design to provide a unified interface for models, while still allowing for modularity in how different types of models are implemented. The modeling stack consists of two layers: the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," and the Model."),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," is the object that is directly used in Ax: model factories return ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," objects, and plotting and cross validation tools operate on a ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge")),". The ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," defines a unified API for all of the models used in Ax via methods like ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict"))," and ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen")),". Internally, it is responsible for transforming Ax objects like ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.arm.Arm"},(0,o.yg)("inlineCode",{parentName:"a"},"Arm"))," and ",(0,o.yg)("a",{parentName:"p",href:"../api/core.html#ax.core.data.Data"},(0,o.yg)("inlineCode",{parentName:"a"},"Data"))," into objects which are then consumed downstream by a Model."),(0,o.yg)("p",null,"Model objects are only used in Ax via a ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge")),". Each Model object defines an API which does not use Ax objects, allowing for modularity of different model types and making it easy to implement new models. For example, the TorchModel defines an API for a model that operates on torch tensors. There is a 1-to-1 link between ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," objects and Model objects. For instance, the TorchModelBridge takes in Ax objects, converts them to torch tensors, and sends them along to the TorchModel. Similar pairings exist for all of the different model types:"),(0,o.yg)("table",null,(0,o.yg)("thead",{parentName:"table"},(0,o.yg)("tr",{parentName:"thead"},(0,o.yg)("th",{parentName:"tr",align:null},"ModelBridge"),(0,o.yg)("th",{parentName:"tr",align:null},"Model"),(0,o.yg)("th",{parentName:"tr",align:null},"Example implementation"),(0,o.yg)("th",{parentName:"tr",align:null}))),(0,o.yg)("tbody",{parentName:"table"},(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/modelbridge.html#module-ax.modelbridge.torch"},(0,o.yg)("inlineCode",{parentName:"a"},"TorchModelBridge"))),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/models.html#ax.models.torch_base.TorchModel"},(0,o.yg)("inlineCode",{parentName:"a"},"TorchModel"))),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/models.html#ax.models.torch.botorch.BotorchModel"},(0,o.yg)("inlineCode",{parentName:"a"},"BotorchModel"))),(0,o.yg)("td",{parentName:"tr",align:null})),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/modelbridge.html#module-ax.modelbridge.discrete"},(0,o.yg)("inlineCode",{parentName:"a"},"DiscreteModelBridge"))),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/models.html#ax.models.discrete_base.DiscreteModel"},(0,o.yg)("inlineCode",{parentName:"a"},"DiscreteModel"))),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/models.html#ax.models.discrete.thompson.ThompsonSampler"},(0,o.yg)("inlineCode",{parentName:"a"},"ThompsonSampler"))),(0,o.yg)("td",{parentName:"tr",align:null})),(0,o.yg)("tr",{parentName:"tbody"},(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/modelbridge.html#module-ax.modelbridge.random"},(0,o.yg)("inlineCode",{parentName:"a"},"RandomModelBridge"))),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/models.html#ax.models.random.base.RandomModel"},(0,o.yg)("inlineCode",{parentName:"a"},"RandomModel"))),(0,o.yg)("td",{parentName:"tr",align:null},(0,o.yg)("a",{parentName:"td",href:"../api/models.html#ax.models.random.sobol.SobolGenerator"},(0,o.yg)("inlineCode",{parentName:"a"},"SobolGenerator"))),(0,o.yg)("td",{parentName:"tr",align:null})))),(0,o.yg)("p",null,"This structure allows for different models like the GP in BotorchModel and the Random Forest in RandomForest to share an interface and use common plotting tools at the level of the ModelBridge, while each is implemented using its own torch or numpy structures."),(0,o.yg)("p",null,"The primary role of the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," is to act as a transformation layer. This includes transformations to the data, search space, and optimization config such as standardization and log transforms, as well as the final transform from Ax objects into the objects consumed by the Model. We now describe how transforms are implemented and used in the ModelBridge."),(0,o.yg)("h2",{id:"transforms"},"Transforms"),(0,o.yg)("p",null,"The transformations in the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," are done by chaining together a set of individual Transform objects. For continuous space models obtained via factory functions (",(0,o.yg)("a",{parentName:"p",href:"/api/data.html#.data.users.adamobeng.fbsource.fbcode.ax.ax.modelbridge.factory.get_sobol"},(0,o.yg)("inlineCode",{parentName:"a"},"get_sobol"))," and ",(0,o.yg)("a",{parentName:"p",href:"/api/data.html#.data.users.adamobeng.fbsource.fbcode.ax.ax.modelbridge.factory.get_GPEI"},(0,o.yg)("inlineCode",{parentName:"a"},"get_GPEI")),"), the following transforms will be applied by default, in this sequence:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.remove_fixed.RemoveFixed"},(0,o.yg)("inlineCode",{parentName:"a"},"RemoveFixed")),": Remove ",(0,o.yg)("a",{parentName:"li",href:"../api/core.html#ax.core.parameter.FixedParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"FixedParameters"))," from the search space."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.choice_encode.OrderedChoiceEncode"},(0,o.yg)("inlineCode",{parentName:"a"},"OrderedChoiceEncode")),": ",(0,o.yg)("a",{parentName:"li",href:"../api/core.html#ax.core.parameter.ChoiceParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"ChoiceParameters"))," with ",(0,o.yg)("inlineCode",{parentName:"li"},"is_ordered")," set to ",(0,o.yg)("inlineCode",{parentName:"li"},"True")," are encoded as a sequence of integers."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.one_hot.OneHot"},(0,o.yg)("inlineCode",{parentName:"a"},"OneHot")),": ",(0,o.yg)("a",{parentName:"li",href:"../api/core.html#ax.core.parameter.ChoiceParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"ChoiceParameters"))," with ",(0,o.yg)("inlineCode",{parentName:"li"},"is_ordered")," set to ",(0,o.yg)("inlineCode",{parentName:"li"},"False")," are one-hot encoded."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.int_to_float.IntToFloat"},(0,o.yg)("inlineCode",{parentName:"a"},"IntToFloat")),": Integer-valued ",(0,o.yg)("a",{parentName:"li",href:"../api/core.html#ax.core.parameter.RangeParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"RangeParameters"))," are converted to have float values."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.log.Log"},(0,o.yg)("inlineCode",{parentName:"a"},"Log")),": ",(0,o.yg)("a",{parentName:"li",href:"../api/core.html#ax.core.parameter.RangeParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"RangeParameters"))," with ",(0,o.yg)("inlineCode",{parentName:"li"},"log_scale")," set to ",(0,o.yg)("inlineCode",{parentName:"li"},"True")," are log transformed."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.unit_x.UnitX"},(0,o.yg)("inlineCode",{parentName:"a"},"UnitX")),": All float ",(0,o.yg)("a",{parentName:"li",href:"../api/core.html#ax.core.parameter.RangeParameter"},(0,o.yg)("inlineCode",{parentName:"a"},"RangeParameters"))," are mapped to ",(0,o.yg)("inlineCode",{parentName:"li"},"[0, 1]"),"."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.derelativize.Derelativize"},(0,o.yg)("inlineCode",{parentName:"a"},"Derelativize")),": Constraints relative to status quo are converted to constraints on raw values."),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"../api/modelbridge.html#ax.modelbridge.transforms.standardize_y.StandardizeY"},(0,o.yg)("inlineCode",{parentName:"a"},"StandardizeY")),": The Y values for each metric are standardized (subtract mean, divide by standard deviation).")),(0,o.yg)("p",null,"Each transform defines both a forward and backwards transform. Arm parameters are passed through the forward transform before being sent along to the Model. The Model works entirely in the transformed space, and when new candidates are generated, they are passed through all of the backwards transforms so the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," returns points in the original space."),(0,o.yg)("p",null,"New transforms can be implemented by creating a subclass of ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.transforms.base.Transform"},(0,o.yg)("inlineCode",{parentName:"a"},"Transform")),", which defines the interface for all transforms. There are separate methods for transforming the search space, optimization config, observation features, and observation data. Transforms that operate on only some aspects of the problem do not need to implement all methods, for instance, ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.transforms.log.Log"},(0,o.yg)("inlineCode",{parentName:"a"},"Log"))," implements only ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.transforms.log.Log.transform_observation_features"},(0,o.yg)("inlineCode",{parentName:"a"},"transform_observation_features"))," (to log transform the parameters), ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.transforms.log.Log.transform_search_space"},(0,o.yg)("inlineCode",{parentName:"a"},"transform_search_space"))," (to log transform the search space bounds), and ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.transforms.log.Log.untransform_observation_features"},(0,o.yg)("inlineCode",{parentName:"a"},"untransform_observation_features"))," (to apply the inverse transform)."),(0,o.yg)("p",null,"The (ordered) list of transforms to apply is an input to the ModelBridge, and so can easily be altered to add new transforms. It is important that transforms be applied in the right order. For instance, the ",(0,o.yg)("inlineCode",{parentName:"p"},"StandardizeY")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Winsorize")," transforms both transform the observed metric values. Applying them in the order ",(0,o.yg)("inlineCode",{parentName:"p"},"[StandardizeY, Winsorize]")," could produce very different results than ",(0,o.yg)("inlineCode",{parentName:"p"},"[Winsorize, StandardizeY]"),". In the former case, outliers would have already been included in the standardization (a procedure sensitive to outliers), and so the second approach that winsorizes first is preferred."),(0,o.yg)("p",null,"See ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#transforms"},"the API reference")," for the full collection of implemented transforms."),(0,o.yg)("h2",{id:"implementing-new-models"},"Implementing new models"),(0,o.yg)("p",null,"The structure of the modeling stack makes it easy to implement new models and use them inside Ax. There are two ways this might be done."),(0,o.yg)("h3",{id:"using-an-existing-model-interface"},"Using an existing Model interface"),(0,o.yg)("p",null,"The easiest way to implement a new model is if it can be adapted to the one of the existing Model interfaces: (",(0,o.yg)("a",{parentName:"p",href:"api/models.html#ax.models.torch_base.TorchModel"},(0,o.yg)("inlineCode",{parentName:"a"},"TorchModel")),", ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.discrete_base.DiscreteModel"},(0,o.yg)("inlineCode",{parentName:"a"},"DiscreteModel")),", or ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.random.base.RandomModel"},(0,o.yg)("inlineCode",{parentName:"a"},"RandomModel")),"). The class definition provides the interface for each of the methods that should be implemented in order for Ax to be able to fully use the new model. Note however that not all methods must need be implemented to use some Ax functionality. For instance, an implementation of ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.torch_base.TorchModel"},(0,o.yg)("inlineCode",{parentName:"a"},"TorchModel"))," that implements only ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.torch_base.TorchModel.fit"},(0,o.yg)("inlineCode",{parentName:"a"},"fit"))," and ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.torch_base.TorchModel.predict"},(0,o.yg)("inlineCode",{parentName:"a"},"predict"))," can be used to fit data and make plots in Ax; however, it will not be able to generate new candidates (requires implementing ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.torch_base.TorchModel.gen"},(0,o.yg)("inlineCode",{parentName:"a"},"gen")),") or be used with Ax's cross validation utility (requires implementing ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.torch_base.TorchModel.cross_validate"},(0,o.yg)("inlineCode",{parentName:"a"},"cross_validate")),")."),(0,o.yg)("p",null,"Once the new model has been implemented, it can be used in Ax with the corresponding ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," from the table above. For instance, suppose a new torch-based model was implemented as a subclass of ",(0,o.yg)("a",{parentName:"p",href:"../api/models.html#ax.models.torch_base.TorchModel"},(0,o.yg)("inlineCode",{parentName:"a"},"TorchModel")),". We can use that model in Ax like:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-python"},"new_model_obj = NewModel(init_args)  # An instance of the new model class\nm = TorchModelBridge(\n    experiment=experiment,\n    search_space=search_space,\n    data=data,\n    model=new_model_obj,\n    transforms=[UnitX, StandardizeY],  # Include the desired set of transforms\n)\n")),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," object ",(0,o.yg)("inlineCode",{parentName:"p"},"m")," can then be used with plotting and cross validation utilities exactly the same way as the built-in models."),(0,o.yg)("h3",{id:"creating-a-new-model-interface"},"Creating a new Model interface"),(0,o.yg)("p",null,"If none of the existing Model interfaces work are suitable for the new model type, then a new interface will have to be created. This involves two steps: creating the new model interface and creating the new model bridge. The new model bridge must be a subclass of ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," that implements ",(0,o.yg)("inlineCode",{parentName:"p"},"ModelBridge._fit"),",  ",(0,o.yg)("inlineCode",{parentName:"p"},"ModelBridge._predict"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"ModelBridge._gen"),", and  ",(0,o.yg)("inlineCode",{parentName:"p"},"ModelBridge._cross_validate"),". The implementation of each of these methods will transform the Ax objects in the inputs into objects required for the interface with the new model type. The model bridge will then call out to the new model interface to do the actual modeling work. All of the ModelBridge/Model pairs in the table above provide examples of how this interface can be defined. The main key is that the inputs on the ",(0,o.yg)("a",{parentName:"p",href:"../api/modelbridge.html#ax.modelbridge.base.ModelBridge"},(0,o.yg)("inlineCode",{parentName:"a"},"ModelBridge"))," side are fixed, but those inputs can then be transformed in whatever way is desired for the downstream Model interface to be that which is most convenient for implementing the model."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-html"},'<script type="text/javascript" src="assets/slice.js"><\/script>\n<script type="text/javascript" src="assets/contour.js"><\/script>\n<script type="text/javascript" src="assets/cv.js"><\/script>\n<script type="text/javascript" src="assets/fitted.js"><\/script>\n')))}h.isMDXComponent=!0}}]);