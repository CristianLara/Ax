"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[40],{3417:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var i=t(4848),a=t(8453),r=t(8987);t(1023),t(290);const o={title:"[RECOMMENDED] Service API",sidebar_label:"[RECOMMENDED] Service API"},s="Service API Example on Hartmann6",l={id:"tutorials/gpei_hartmann_service/index",title:"[RECOMMENDED] Service API",description:"<LinkButtons",source:"@site/../docs/tutorials/gpei_hartmann_service/index.mdx",sourceDirName:"tutorials/gpei_hartmann_service",slug:"/tutorials/gpei_hartmann_service/",permalink:"/Ax/docs/tutorials/gpei_hartmann_service/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"[RECOMMENDED] Service API",sidebar_label:"[RECOMMENDED] Service API"},sidebar:"tutorials",previous:{title:"Overview",permalink:"/Ax/docs/tutorials/"},next:{title:"Loop API",permalink:"/Ax/docs/tutorials/gpei_hartmann_loop/"}},c={},d=[{value:"1. Initialize client",id:"1-initialize-client",level:2},{value:"2. Set up experiment",id:"2-set-up-experiment",level:2},{value:"3. Define how to evaluate trials",id:"3-define-how-to-evaluate-trials",level:2},{value:"4. Run optimization loop",id:"4-run-optimization-loop",level:2},{value:"How many trials can run in parallel?",id:"how-many-trials-can-run-in-parallel",level:3},{value:"How to view all existing trials during optimization?",id:"how-to-view-all-existing-trials-during-optimization",level:3},{value:"5. Retrieve best parameters",id:"5-retrieve-best-parameters",level:2},{value:"6. Plot the response surface and optimization trace",id:"6-plot-the-response-surface-and-optimization-trace",level:2},{value:"7. Save / reload optimization to JSON / SQL",id:"7-save--reload-optimization-to-json--sql",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.A,{githubUrl:"",colabUrl:""}),"\n",(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"service-api-example-on-hartmann6",children:"Service API Example on Hartmann6"})}),"\n",(0,i.jsx)(n.p,{children:"The Ax Service API is designed to allow the user to control scheduling of trials and\ndata computation while having an easy to use interface with Ax."}),"\n",(0,i.jsx)(n.p,{children:"The user iteratively:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Queries Ax for candidates"}),"\n",(0,i.jsx)(n.li,{children:"Schedules / deploys them however they choose"}),"\n",(0,i.jsx)(n.li,{children:"Computes data and logs to Ax"}),"\n",(0,i.jsx)(n.li,{children:"Repeat"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from ax.service.ax_client import AxClient, ObjectiveProperties\nfrom ax.utils.measurement.synthetic_functions import hartmann6\nfrom ax.utils.notebook.plotting import init_notebook_plotting, render\n\ninit_notebook_plotting()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"1-initialize-client",children:"1. Initialize client"}),"\n",(0,i.jsx)(n.p,{children:"Create a client object to interface with Ax APIs. By default this runs locally without\nstorage."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ax_client = AxClient()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2-set-up-experiment",children:"2. Set up experiment"}),"\n",(0,i.jsxs)(n.p,{children:["An experiment consists of a ",(0,i.jsx)(n.strong,{children:"search space"})," (parameters and parameter constraints) and\n",(0,i.jsx)(n.strong,{children:"optimization configuration"})," (objectives and outcome constraints). Note that:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Only ",(0,i.jsx)(n.code,{children:"parameters"}),", and ",(0,i.jsx)(n.code,{children:"objectives"})," arguments are required."]}),"\n",(0,i.jsxs)(n.li,{children:["Dictionaries in ",(0,i.jsx)(n.code,{children:"parameters"}),' have the following required keys: "name" - parameter\nname, "type" - parameter type ("range", "choice" or "fixed"), "bounds" for range\nparameters, "values" for choice parameters, and "value" for fixed parameters.']}),"\n",(0,i.jsxs)(n.li,{children:["Dictionaries in ",(0,i.jsx)(n.code,{children:"parameters"}),' can optionally include "value_type" ("int", "float",\n"bool" or "str"), "log_scale" flag for range parameters, and "is_ordered" flag for\nchoice parameters.']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"parameter_constraints"}),' should be a list of strings of form "p1 >= p2" or "p1 + p2 <=\nsome_bound".']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"outcome_constraints"}),' should be a list of strings of form "constrained_metric <=\nsome_bound".']}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'ax_client.create_experiment(\n    name="hartmann_test_experiment",\n    parameters=[\n        {\n            "name": "x1",\n            "type": "range",\n            "bounds": [0.0, 1.0],\n            "value_type": "float",  # Optional, defaults to inference from type of "bounds".\n            "log_scale": False,  # Optional, defaults to False.\n        },\n        {\n            "name": "x2",\n            "type": "range",\n            "bounds": [0.0, 1.0],\n        },\n        {\n            "name": "x3",\n            "type": "range",\n            "bounds": [0.0, 1.0],\n        },\n        {\n            "name": "x4",\n            "type": "range",\n            "bounds": [0.0, 1.0],\n        },\n        {\n            "name": "x5",\n            "type": "range",\n            "bounds": [0.0, 1.0],\n        },\n        {\n            "name": "x6",\n            "type": "range",\n            "bounds": [0.0, 1.0],\n        },\n    ],\n    objectives={"hartmann6": ObjectiveProperties(minimize=True)},\n    parameter_constraints=["x1 + x2 <= 2.0"],  # Optional.\n    outcome_constraints=["l2norm <= 1.25"],  # Optional.\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"3-define-how-to-evaluate-trials",children:"3. Define how to evaluate trials"}),"\n",(0,i.jsxs)(n.p,{children:['When using Ax a service, evaluation of parameterizations suggested by Ax is done either\nlocally or, more commonly, using an external scheduler. Below is a dummy evaluation\nfunction that outputs data for two metrics "hartmann6" and "l2norm". Note that all\nreturned metrics correspond to either the ',(0,i.jsx)(n.code,{children:"objectives"})," set on experiment creation or the\nmetric names mentioned in ",(0,i.jsx)(n.code,{children:"outcome_constraints"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\n\ndef evaluate(parameterization):\n    x = np.array([parameterization.get(f"x{i+1}") for i in range(6)])\n    # In our case, standard error is 0, since we are computing a synthetic function.\n    return {"hartmann6": (hartmann6(x), 0.0), "l2norm": (np.sqrt((x**2).sum()), 0.0)}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Result of the evaluation should generally be a mapping of the format:\n",(0,i.jsx)(n.code,{children:"\\{metric_name -> (mean, SEM)\\}"}),". If there is only one metric in the experiment \u2013 the\nobjective \u2013 then evaluation function can return a single tuple of mean and SEM, in which\ncase Ax will assume that evaluation corresponds to the objective. ",(0,i.jsx)(n.em,{children:"It can also return\nonly the mean as a float, in which case Ax will treat SEM as unknown and use a model\nthat can infer it."})]}),"\n",(0,i.jsxs)(n.p,{children:['For more details on evaluation function, refer to the "Trial Evaluation" section in the\nAx docs at ',(0,i.jsx)(n.a,{href:"https://ax.dev/",children:"ax.dev"})]}),"\n",(0,i.jsx)(n.h2,{id:"4-run-optimization-loop",children:"4. Run optimization loop"}),"\n",(0,i.jsx)(n.p,{children:"With the experiment set up, we can start the optimization loop."}),"\n",(0,i.jsx)(n.p,{children:"At each step, the user queries the client for a new trial then submits the evaluation of\nthat trial back to the client."}),"\n",(0,i.jsxs)(n.p,{children:["Note that Ax auto-selects an appropriate optimization algorithm based on the search\nspace. For more advance use cases that require a specific optimization algorithm, pass a\n",(0,i.jsx)(n.code,{children:"generation_strategy"})," argument into the ",(0,i.jsx)(n.code,{children:"AxClient"})," constructor. Note that when Bayesian\nOptimization is used, generating new trials may take a few minutes."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"for i in range(25):\n    parameterization, trial_index = ax_client.get_next_trial()\n    # Local evaluation here can be replaced with deployment to external system.\n    ax_client.complete_trial(trial_index=trial_index, raw_data=evaluate(parameterization))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"how-many-trials-can-run-in-parallel",children:"How many trials can run in parallel?"}),"\n",(0,i.jsx)(n.p,{children:"By default, Ax restricts number of trials that can run in parallel for some optimization\nstages, in order to improve the optimization performance and reduce the number of trials\nthat the optimization will require. To check the maximum parallelism for each\noptimization stage:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ax_client.get_max_parallelism()\n"})}),"\n",(0,i.jsxs)(n.p,{children:['The output of this function is a list of tuples of form (number of trials, max\nparallelism), so the example above means "the max parallelism is 12 for the first 12\ntrials and 3 for all subsequent trials." This is because the first 12 trials are\nproduced quasi-randomly and can all be evaluated at once, and subsequent trials are\nproduced via Bayesian optimization, which converges on optimal point in fewer trials\nwhen parallelism is limited. ',(0,i.jsx)(n.code,{children:"MaxParallelismReachedException"})," indicates that the\nparallelism limit has been reached \u2013\u2013 refer to the 'Service API Exceptions Meaning and\nHandling' section at the end of the tutorial for handling."]}),"\n",(0,i.jsx)(n.h3,{id:"how-to-view-all-existing-trials-during-optimization",children:"How to view all existing trials during optimization?"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ax_client.generation_strategy.trials_as_df\n"})}),"\n",(0,i.jsx)(n.h2,{id:"5-retrieve-best-parameters",children:"5. Retrieve best parameters"}),"\n",(0,i.jsx)(n.p,{children:"Once it's complete, we can access the best parameters found, as well as the\ncorresponding metric values."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"best_parameters, values = ax_client.get_best_parameters()\nbest_parameters\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"means, covariances = values\nmeans\n"})}),"\n",(0,i.jsx)(n.p,{children:"For comparison, Hartmann6 minimum:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"hartmann6.fmin\n"})}),"\n",(0,i.jsx)(n.h2,{id:"6-plot-the-response-surface-and-optimization-trace",children:"6. Plot the response surface and optimization trace"}),"\n",(0,i.jsx)(n.p,{children:'Here we arbitrarily select "x1" and "x2" as the two parameters to plot for both metrics,\n"hartmann6" and "l2norm".'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"render(ax_client.get_contour_plot())\n"})}),"\n",(0,i.jsx)(n.p,{children:'We can also retrieve a contour plot for the other metric, "l2norm" \u2013\u2013 say, we are\ninterested in seeing the response surface for parameters "x3" and "x4" for this one.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'render(ax_client.get_contour_plot(param_x="x3", param_y="x4", metric_name="l2norm"))\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here we plot the optimization trace, showing the progression of finding the point with\nthe optimal objective:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"render(\n    ax_client.get_optimization_trace(objective_optimum=hartmann6.fmin)\n)  # Objective_optimum is optional.\n"})}),"\n",(0,i.jsx)(n.h2,{id:"7-save--reload-optimization-to-json--sql",children:"7. Save / reload optimization to JSON / SQL"}),"\n",(0,i.jsxs)(n.p,{children:["We can serialize the state of optimization to JSON and save it to a ",(0,i.jsx)(n.code,{children:".json"})," file or save\nit to the SQL backend. For the former:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ax_client.save_to_json_file()  # For custom filepath, pass `filepath` argument.\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"restored_ax_client = (\n    AxClient.load_from_json_file()\n)  # For custom filepath, pass `filepath` argument.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To store state of optimization to an SQL backend, first follow\n",(0,i.jsx)(n.a,{href:"https://ax.dev/docs/storage.html#sql",children:"setup instructions"})," on Ax website."]}),"\n",(0,i.jsxs)(n.p,{children:["Having set up the SQL backend, pass ",(0,i.jsx)(n.code,{children:"DBSettings"})," to ",(0,i.jsx)(n.code,{children:"AxClient"})," on instantiation (note\nthat ",(0,i.jsx)(n.code,{children:"SQLAlchemy"})," dependency will have to be installed \u2013 for installation, refer to\n",(0,i.jsx)(n.a,{href:"https://ax.dev/docs/installation.html#optional-dependencies",children:"optional dependencies"})," on\nAx website):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from ax.storage.sqa_store.structs import DBSettings\n\n# URL is of the form "dialect+driver://username:password@host:port/database".\ndb_settings = DBSettings(url="sqlite:///foo.db")\n# Instead of URL, can provide a `creator function`; can specify custom encoders/decoders if necessary.\nnew_ax = AxClient(db_settings=db_settings)\n'})}),"\n",(0,i.jsxs)(n.p,{children:["When valid ",(0,i.jsx)(n.code,{children:"DBSettings"})," are passed into ",(0,i.jsx)(n.code,{children:"AxClient"}),", a unique experiment name is a\nrequired argument (",(0,i.jsx)(n.code,{children:"name"}),") to ",(0,i.jsx)(n.code,{children:"ax_client.create_experiment"}),". The ",(0,i.jsx)(n.strong,{children:"state of the\noptimization is auto-saved"})," any time it changes (i.e. a new trial is added or\ncompleted, etc)."]}),"\n",(0,i.jsxs)(n.p,{children:["To reload an optimization state later, instantiate ",(0,i.jsx)(n.code,{children:"AxClient"})," with the same ",(0,i.jsx)(n.code,{children:"DBSettings"}),"\nand use ",(0,i.jsx)(n.code,{children:'ax_client.load_experiment_from_database(experiment_name="my_experiment")'}),"."]}),"\n",(0,i.jsx)(n.h1,{id:"special-cases",children:"Special Cases"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Evaluation failure"}),": should any optimization iterations fail during evaluation,\n",(0,i.jsx)(n.code,{children:"log_trial_failure"})," will ensure that the same trial is not proposed again."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"_, trial_index = ax_client.get_next_trial()\nax_client.log_trial_failure(trial_index=trial_index)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Adding custom trials"}),": should there be need to evaluate a specific parameterization,\n",(0,i.jsx)(n.code,{children:"attach_trial"})," will add it to the experiment."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'ax_client.attach_trial(\n    parameters={"x1": 0.9, "x2": 0.9, "x3": 0.9, "x4": 0.9, "x5": 0.9, "x6": 0.9}\n)\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Need to run many trials in parallel"}),": for optimal results and optimization\nefficiency, we strongly recommend sequential optimization (generating a few trials, then\nwaiting for them to be completed with evaluation data). However, if your use case needs\nto dispatch many trials in parallel before they are updated with data and you are\nrunning into the ",(0,i.jsx)(n.em,{children:'"All trials for current model have been generated, but not enough data\nhas been observed to fit next model"'})," error, instantiate ",(0,i.jsx)(n.code,{children:"AxClient"})," as\n",(0,i.jsx)(n.code,{children:"AxClient(enforce_sequential_optimization=False)"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nonlinear parameter constraints and/or constraints on non-Range parameters:"})," Ax\nparameter constraints can currently only support linear inequalities\n(",(0,i.jsx)(n.a,{href:"https://github.com/facebook/Ax/issues/153",children:"discussion"}),"). Users may be able to simulate\nthis functionality, however, by substituting the following ",(0,i.jsx)(n.code,{children:"evaluate"})," function for that\ndefined in section 3 above."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def evaluate(parameterization):\n    x = np.array([parameterization.get(f"x{i+1}") for i in range(6)])\n    # First calculate the nonlinear quantity to be constrained.\n    l2norm = np.sqrt((x**2).sum())\n    # Then define a constraint consistent with an outcome constraint on this experiment.\n    if l2norm > 1.25:\n        return {"l2norm": (l2norm, 0.0)}\n    return {"hartmann6": (hartmann6(x), 0.0), "l2norm": (l2norm, 0.0)}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For this to work, the constraint quantity (",(0,i.jsx)(n.code,{children:"l2norm"})," in this case) should have a\ncorresponding outcome constraint on the experiment. See the outcome_constraint arg to\nax_client.create_experiment in section 2 above for how to specify outcome constraints."]}),"\n",(0,i.jsx)(n.p,{children:"This setup accomplishes the following:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Allows computation of an arbitrarily complex constraint value."}),"\n",(0,i.jsx)(n.li,{children:"Skips objective computation when the constraint is violated, useful when the\nobjective is relatively expensive to compute."}),"\n",(0,i.jsx)(n.li,{children:"Constraint metric values are returned even when there is a violation. This helps the\nmodel understand + avoid constraint violations."}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"service-api-exceptions-meaning-and-handling",children:"Service API Exceptions Meaning and Handling"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://ax.dev/api/exceptions.html#ax.exceptions.core.DataRequiredError",children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"DataRequiredError"})})}),":\nAx generation strategy needs to be updated with more data to proceed to the next\noptimization model. When the optimization moves from initialization stage to the\nBayesian optimization stage, the underlying BayesOpt model needs sufficient data to\ntrain. For optimal results and optimization efficiency (finding the optimal point in the\nleast number of trials), we recommend sequential optimization (generating a few trials,\nthen waiting for them to be completed with evaluation data). Therefore, the correct way\nto handle this exception is to wait until more trial evaluations complete and log their\ndata via ",(0,i.jsx)(n.code,{children:"ax_client.complete_trial(...)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["However, if there is strong need to generate more trials before more data is available,\ninstantiate ",(0,i.jsx)(n.code,{children:"AxClient"})," as ",(0,i.jsx)(n.code,{children:"AxClient(enforce_sequential_optimization=False)"}),". With this\nsetting, as many trials will be generated from the initialization stage as requested,\nand the optimization will move to the BayesOpt stage whenever enough trials are\ncompleted."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://ax.dev/api/modelbridge.html#ax.modelbridge.generation_strategy.MaxParallelismReachedException",children:(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"MaxParallelismReachedException"})})}),":\ngeneration strategy restricts the number of trials that can be ran simultaneously (to\nencourage sequential optimization), and the parallelism limit has been reached. The\ncorrect way to handle this exception is the same as ",(0,i.jsx)(n.code,{children:"DataRequiredError"})," \u2013 to wait until\nmore trial evluations complete and log their data via ",(0,i.jsx)(n.code,{children:"ax_client.complete_trial(...)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In some cases higher parallelism is important, so\n",(0,i.jsx)(n.code,{children:"enforce_sequential_optimization=False"})," kwarg to AxClient allows to suppress limiting of\nparallelism. It's also possible to override the default parallelism setting for all\nstages of the optimization by passing ",(0,i.jsx)(n.code,{children:"choose_generation_strategy_kwargs"})," to\n",(0,i.jsx)(n.code,{children:"ax_client.create_experiment"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'ax_client = AxClient()\nax_client.create_experiment(\n    parameters=[\n        {"name": "x", "type": "range", "bounds": [-5.0, 10.0]},\n        {"name": "y", "type": "range", "bounds": [0.0, 15.0]},\n    ],\n    # Sets max parallelism to 10 for all steps of the generation strategy.\n    choose_generation_strategy_kwargs={"max_parallelism_override": 10},\n)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ax_client.get_max_parallelism()  # Max parallelism is now 10 for all stages of the optimization.\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1023:(e,n,t)=>{t.d(n,{A:()=>m});t(6540);var i,a=new Uint8Array(16);function r(){if(!i&&!(i="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return i(a)}const o=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;const s=function(e){return"string"==typeof e&&o.test(e)};for(var l=[],c=0;c<256;++c)l.push((c+256).toString(16).substr(1));const d=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=(l[e[n+0]]+l[e[n+1]]+l[e[n+2]]+l[e[n+3]]+"-"+l[e[n+4]]+l[e[n+5]]+"-"+l[e[n+6]]+l[e[n+7]]+"-"+l[e[n+8]]+l[e[n+9]]+"-"+l[e[n+10]]+l[e[n+11]]+l[e[n+12]]+l[e[n+13]]+l[e[n+14]]+l[e[n+15]]).toLowerCase();if(!s(t))throw TypeError("Stringified UUID is invalid");return t};const h=function(e,n,t){var i=(e=e||{}).random||(e.rng||r)();if(i[6]=15&i[6]|64,i[8]=63&i[8]|128,n){t=t||0;for(var a=0;a<16;++a)n[t+a]=i[a];return n}return d(i)};var p=t(4848);const m=function(e){return(0,p.jsxs)("div",{style:{backgroundColor:"lightgray",marginBottom:"var(--ifm-leading)",borderRadius:"var(--ifm-global-radius)",boxShadow:"var(--ifm-global-shadow-lw)",overflow:"hidden",padding:"10px",font:"var(--ifm-code-font-size) / var(--ifm-pre-line-height) var(--ifm-font-family-monospace)"},children:[(0,p.jsx)("span",{style:{color:"red"},children:"Out: "}),(0,p.jsx)("pre",{style:{margin:"0px",backgroundColor:"inherit"},children:e.children.split("\n").map((function(e){return(0,p.jsx)("p",{style:{marginBottom:"0px"},children:e},h())}))})]})}},8987:(e,n,t)=>{t.d(n,{A:()=>r});t(6540);var i=t(8774),a=t(4848);const r=function(e){var n=e.githubUrl,t=e.colabUrl;return(0,a.jsxs)("div",{className:"link-buttons",children:[(0,a.jsx)(i.A,{to:n,children:"Open in GitHub"}),(0,a.jsx)("div",{}),(0,a.jsx)(i.A,{to:t,children:"Run in Google Colab"})]})}},290:(e,n,t)=>{t(6540);var i=t(3259),a=t.n(i),r=(t(2303),t(4848));a()({loader:function(){return t.e(236).then(t.bind(t,1236))},loading:function(e){return e.timedOut?(0,r.jsx)("blockquote",{children:"Error: Loading Plotly timed out."}):(0,r.jsx)("div",{children:"loading..."})},timeout:1e4})},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(6540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);